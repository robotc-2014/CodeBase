#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    leftServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    rightServo,           tServoStandard)
#pragma config(Servo,  srvo_S2_C1_1,    servo7,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_2,    servo8,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c" // handles bluetooth messages
#include "C:\Program Files (x86)\Robomatter Inc\ROBOTC Development Environment\Sample Programs\NXT\3rd Party Sensor Drivers\drivers\hitechnic-irseeker-v2.h"

#define BOUND(n, l, h) (((n) < (l))? (l): ((n) > (h))? (h): (n)) // Macro (custom PID control)
#define max(a, b)               (((a) > (b))? (a): (b))					 // Macro (IR directional max)
#define DEADBAND(n,t)           ((abs(n) > (t))? (n): 0) 				 // Macro (gyro deadband)

#define PI                   3.1415926535897932384626433832795028841971 // PI w/th < digits (less computationally taxing)
#define ticksPerRevolution   1440.0 // encoder ticks per revolution
#define gearRatio            (1/1)  // motor : wheel (gear ratio)
#define diameter          	 4  	 // wheel diameter (inches)
#define circumference     	 (PI * diameter)
#define inchesPerTick        (circumference*gearRatio/ticksPerRevolution)


//#define __HTSMUX_SUPPORT__ // Sensor Multiplexer support

#define GYROO_INVERSE           0x0001
#define GYROO_FILTER            0x0002
#define GYROF_HTSMUX            0x0001

#define GYRO_SAMPLING_PERIOD    5      // sampling time
#define GYRO_NUM_CAL_SAMPLES    100
#define GYRO_CAL_INTERVAL       10

#ifdef __HTSMUX_SUPPORT__
#define GyroGetRawValue(g)  (((g).flags & GYROF_HTSMUX)? \ // HTSMUX support
HTSMUXreadAnalogue((tMUXSensor)(g).sensorID): \
SensorValue[(g).sensorID])
#else
#define GyroGetRawValue(g)  SensorValue[(g).sensorID]
#endif


#define GyroGetTurnRate(g)      ((g).turnRate) // get turn rate
#define GyroGetHeading(g)       ((g).heading) // get heading


typedef struct // kalman variables
{
	float Q;
	float R;
	float prevP;
	float prevXEst;
	bool fInitialized;
} KALMAN;

void KalmanInit(KALMAN &kalman, float Q = 0.022, float R = 0.617) // filter var init
{
	kalman.Q = Q;
	kalman.R = R;
	kalman.prevP = 0.0;
	kalman.prevXEst = 0.0;
	kalman.fInitialized = false;
	return;
}

float KalmanFilter(KALMAN &kalman, float data) // kalman filter => https://en.wikipedia.org/wiki/Kalman_filter
{
	if (!kalman.fInitialized)
	{
		kalman.prevXEst = data;
		kalman.fInitialized = true;
	}

	float tempP = kalman.prevP + kalman.Q;
	float K = tempP/(tempP + kalman.R);
	float xEst = kalman.prevXEst + K*(data - kalman.prevXEst);
	float P = (1 - K)*tempP;

	kalman.prevP = P;

	kalman.prevXEst = xEst;
	return kalman.prevXEst;
}

void moveinches(int distance)
{
	nMotorEncoder[Right] = 0;
	nMotorEncoder[Left] = 0;
	while (abs(nMotorEncoder[Right]) < abs(distance/inchesPerTick))
	{
		motor[Right] = 50;
		motor[Left] = 50;
	}
}

typedef struct								// gyro vars
{
	tSensors        sensorID;
	int             options;
	int             flags;
	int             zeroOffset;
	int             deadBand;
	unsigned long   prevTime;
	unsigned long   nextPeriod;
	int             turnRate;
	float           heading;
	KALMAN      kalman;
} GYRO;

void GyroCal(GYRO &gyro, int numSamples, int calInterval) // gyro calibration (deadband and offset)
{
	int i;
	int turnRate;
	int minValue, maxValue;
	float sum = 0.0;

	gyro.zeroOffset = 0;
	gyro.deadBand = 0;
	minValue = 1023;
	maxValue = 0;

	for (i = 0; i < numSamples; i++)
	{
		turnRate = GyroGetRawValue(gyro);
		sum += turnRate;

		if (turnRate < minValue)
		{
			minValue = turnRate;   // readings min
		}
		else if (turnRate > maxValue)
		{
			maxValue = turnRate;					// readings max
		}

		wait1Msec(calInterval); // calibration interval
	}

	gyro.zeroOffset = round(sum/numSamples); // offset = sum/numSamples
	gyro.deadBand = round((float)(maxValue - minValue)/2.0);  // deadband = (max - min)/2


	nxtDisplayTextLine(5, "min=%d, max=%d", minValue, maxValue); // gyro debugging
	nxtDisplayTextLine(6, "zeroOffset=%d", gyro.zeroOffset);
	nxtDisplayTextLine(7, "deadBand=%d", gyro.deadBand);
	wait1Msec(17);

	return;
}

void GyroTask(GYRO &gyro)									// gyroTask updating gyro feedback
{
	unsigned long currTime = nPgmTime;
	if (currTime >= gyro.nextPeriod)
	{
		gyro.nextPeriod += GYRO_SAMPLING_PERIOD;
		gyro.turnRate = GyroGetRawValue(gyro);
		gyro.turnRate -= gyro.zeroOffset;
		gyro.turnRate = DEADBAND(gyro.turnRate, gyro.deadBand);    // gyro turn rate deadzoning

		if (gyro.options & GYROO_INVERSE)
		{
			gyro.turnRate = -gyro.turnRate;
		}

		if (gyro.options & GYROO_FILTER)
		{
			gyro.turnRate = KalmanFilter(gyro.kalman, gyro.turnRate);
		}

		gyro.heading += (float)gyro.turnRate*(currTime - gyro.prevTime)/1000;
		gyro.prevTime = currTime;
	}

	return;
}

void GyroReset(GYRO &gyro) // reset gyro
{
	GyroTask(gyro);
	gyro.heading = 0;

	return;
}

void GyroInit(GYRO &gyro, tSensors sensorID, int options = 0) // initialize gyro
{
	gyro.sensorID = sensorID;
	gyro.options = options;
	gyro.flags = 0;

	KalmanInit(gyro.kalman);

	if (SensorType[sensorID] != sensorAnalogInactive)
	{
		SetSensorType(sensorID, sensorAnalogInactive);
		wait1Msec(100);
	}

	GyroCal(gyro, GYRO_NUM_CAL_SAMPLES, GYRO_CAL_INTERVAL); // calibrate gyro
	gyro.prevTime = nPgmTime;
	gyro.nextPeriod = gyro.prevTime;
	GyroReset(gyro);  // reset

	return;
}

#ifdef __HTSMUX_SUPPORT__

void GyroInit(GYRO &gyro, tMUXSensor sensorID, int options = 0)  // init for HTSMUX
{
	gyro.sensorID = (tSensors)sensorID;
	gyro.options = options;
	gyro.flags = GYROF_HTSMUX;


	KalmanInit(gyro.kalman);


	GyroCal(gyro, GYRO_NUM_CAL_SAMPLES, GYRO_CAL_INTERVAL);
	gyro.prevTime = nPgmTime;
	gyro.nextPeriod = gyro.prevTime;
	GyroReset(gyro);
	return;
}
#endif

GYRO g_Gyro;

float g_turnTarget = 0.0;
bool  g_turnEnabled = false;
float g_turnTolerance = 0.1;    // needs to be tuned
float g_turnKp = 1.0;          // needs to be tuned
//float g_driveTarget = 0.0;
//bool  g_driveEnabled = false;
//float g_driveTolerance = 0.5;	// needs to be tuned
//float g_driveKp = 1.0;				// needs to be tuned


void clamp() {
	servoTarget[leftServo] = 255;     //will not work
	servoTarget[rightServo] = 0;
}

void unclamp() {
	servoTarget[leftServo] = 0;     //will not work
	servoTarget[rightServo] = 255;
}

void turn(float angle)
{
	GyroReset(g_Gyro);
	g_turnTarget = angle;
	g_turnEnabled = true;
}

void TurnTask()
{
	if (g_turnEnabled)
	{
		float error = GyroGetHeading(g_Gyro) - g_turnTarget;

		if (abs(error) > g_turnTolerance)
		{
			int turnPower = BOUND((int)(g_turnKp*error), -50, 50);
			if (abs(turnPower) <= 6) {
				turnPower = sgn(turnPower) * 6;
			}
			motor[Left] = turnPower;
			motor[Right] = -turnPower;
		}
		else
		{
			motor[Left] = 0;
			motor[Right] = 0;
			g_turnEnabled = false;
			nxtDisplayTextLine(7, "err=%f", error);
		}
		nxtDisplayTextLine(3, "Heading=%f", GyroGetHeading(g_Gyro));
		nxtDisplayTextLine(6, "target=%f,tol=%f", g_turnTarget, g_turnTolerance);
	}
}

float GetDriveDistance()
{
	return (float)(nMotorEncoder[Left] + nMotorEncoder[Right])/2.0*inchesPerTick;

	// if gyro is accounting for alignment, the encoder ticks on one side decrease and the encoder ticks on the other
	// side increase proportionally, so if you add the encoder ticks on both sides and average, you cancel out the tick
	// differential created by the alignment correction and multiply by inches/tick to get the distance to still drive in
	// inches

}

/*void setDist(float distance)
{
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;
	GyroReset(g_Gyro);
	g_driveTarget = -distance;
	g_driveEnabled = true;
}

void DriveTask()
{
	if (g_driveEnabled)
	{
		float driveErr = g_driveTarget - GetDriveDistance();

		if (abs(driveErr) > g_driveTolerance)
		{
			int drivePower = BOUND((int)(g_driveKp*driveErr), -70, 70);
			float turnErr = GyroGetHeading(g_Gyro);
			int turnPower = BOUND((int)(g_turnKp*turnErr), -50, 50);

			motor[Left] = BOUND(drivePower + turnPower, -80, 80);
			motor[Right] = BOUND(drivePower - turnPower, -80, 80);
			if (abs(motor[Left]) <= 7 || abs(motor[Right]) <= 7) {
				motor[Left] = sgn(motor[Left]) * 15;
				motor[Right] = sgn(motor[Right]) * 15;
			}
		}

		nxtDisplayTextLine(7, "drvErr=%f", driveErr);
	}
	else
	{
		motor[Left] = 0;
		motor[Right] = 0;
		g_driveEnabled = false;
	}
	nxtDisplayTextLine(4, "Distance=%f", GetDriveDistance());
}
*/

float dirAC(tSensors link)
{
	static float prevDir = 0.0;
	float currDir;
	int acS[5];
	int idx;

	idx = HTIRS2readACDir(link);
	currDir = (float)idx;
	if (idx == 0)
	{
		currDir = prevDir;
	}
	else if (HTIRS2readAllACStrength(link, acS[0], acS[1], acS[2], acS[3], acS[4]))
	{
		idx = (idx - 1)/2;
		if ((idx < 4) && (acS[idx] != 0) && (acS[idx + 1] != 0))
		{
			currDir += (float)(acS[idx + 1] - acS[idx])/
			max(acS[idx], acS[idx + 1]);
		}
	}
	prevDir = currDir;

	return currDir;
}

//int detectField() {
//	// go forward 43 inches, turn left 39.3 degrees and go back [-] 4 inches then run the detect field procedure
//	float acDir = dirAC(IRSeeker2);
//	int fieldLayout = 0;
//	if (acDir > 0 && acDir < 5)
//	{
//		fieldLayout = 1;
//	}
//	if (acDir == 5) {
//		fieldLayout = 2;
//	}
//	if (acDir > 5) {
//		fieldLayout = 3;
//	}
//	return fieldLayout;
//}

//void kickstand() {
//	int fieldLayout = detectField();

//	if (fieldLayout == 1) {
//		// go hit the kickstand
//	}
//	if (fieldLayout == 2) {
//		// go hit the kickstand

//	}
//	if (fieldLayout == 3) {
//		// go hit the kickstand
//	}

//}

void initializeRobot()
{
//	HTIRS2setDSPMode(IRSeeker2, DSP_1200);
	GyroInit(g_Gyro, gyroSensor, 0);
	//GyroInit(g_Gyro, gyroSensor, GYROF_HTSMUX);
  unclamp();
	nMotorEncoder[Left] = 0; nMotorEncoder[Right] = 0;
	return;
}

task main()
{
	int step = 0; // state machine

	bDisplayDiagnostics = false;
	eraseDisplay();
	initializeRobot();

	waitForStart(); // Wait for the beginning of autonomous phase.

	bool mainLoop = true;

	while (mainLoop)
	{
		GyroTask(g_Gyro); // continous gyro integration

		nxtDisplayTextLine(5, "Step = %d", step);
		switch (step)
		{
		case 0:
			nMotorEncoder[Right] = 0;
      moveinches(-80.00); //negative is reverse direction
			step++;
			break;

		case 1:

//			if (g_turnEnabled == false)
//			{
			step++;
//			}
			break;

		case 2:
			clamp();
			step++;
			break;

		case 3:

			step++;
			break;

		case 4:

			turn(27.64); //negative is the left direction
			step++;
			break;

		case 5:

			if (g_turnEnabled == false)
			{
				step++;

			}
			break;

		case 6:
			moveinches(111);
			step++;
			break;

		case 7:
			//if (g_driveEnabled == false)
			//{
				step++;
			//}
			break;

		case 8:
			turn(64.0);
			step++;
			break;

		case 9:
			if (g_turnEnabled == false)
			{
				step++;
			}
			break;

		case 10:
			moveinches(12.0);
			step++;
			break;
		} // last bracket of switch ("case-based") function

		TurnTask();
		//DriveTask();
		wait1Msec(10);
	}
}
